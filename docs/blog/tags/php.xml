<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[devGiants]]></title>
    <link href="/blog/tags/php.xml" rel="self"/>
    <link href="/"/>
    <updated>2021-04-12T12:17:21+02:00</updated>
    <id>/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Named constructor]]></title>
            <link href="/blog/2020/03/04/named-constructors/"/>
            <updated>2020-03-04T17:30:00+01:00</updated>
            <id>/blog/2020/03/04/named-constructors/</id>
            <content type="html"><![CDATA[<h2 id="how-to-create-an-instance-%3F">How to create an instance ?</h2>

<h3 id="classical-oop">Classical OOP</h3>

<p>In classical OOP approach, you will use the
<code>__construct</code> magic method to do the job. Let's reuse our <code>Ticket</code> entity 
described in <a href="https://devgiants.fr/blog/2020/03/02/symfony-workflow-component-walkthrough-part-1/">SymfonyWorkflow journey - part 1</a></p>

<pre><code class="php">/**
 * All attributes protected, stick to SOLID principles    
 */
class Ticket
{       
    protected $id;

    protected $title;

    /**
    * Classical constructor magic method
    */
    public function __construct()
    {

    }

}
</code></pre>

<p><em>Note : I cleared unnecessary stuff, such as getters/setters, annotations... 
So the rest look much more like a <strong>value object</strong>.</em></p>

<p>So far, so good. What's wrong with this? Nothing technically speaking, <strong>this does the job</strong>.
But what if the object is complex, and you have more than one way to create instance (from a business POV) ?
This is where <strong>named constructors</strong> come into light.</p>

<h3 id="named-constructor">Named constructor</h3>

<p>This is mostly a kind of static factory (a system to create an object) embedded in object class itself. Above example 
become :</p>

<p>```php
/**
  * All attributes protected, stick to SOLID principles<br />
  */
 class Ticket
 {<br />
     protected $id;</p>

<pre><code> protected $title;

 /**
 * Constructor becomes protected to ensure there is direct call
 */
 protected function __construct()
 {

 }

 /**
 * Named constructor example. Static to be called from class itself
 */
 public static function fromTitle(string $title): self
 {
    $ticket = new static();
    $ticket-&gt;setTitle($title);
    return $ticket;  
 } 
</code></pre>

<p>}
 ```</p>

<p>So instead of doing <code>$ticket = new Ticket()</code> you would do <code>$ticket = Ticket::fromTitle('new title')</code>.</p>

<p><em>Notes : 
- _Pay attention to <code>self</code> return type. This allow not to hardcode the class return type, hence offers 
dynamism on override (with precautions though).
- _In the same way, the <code>new static()</code> allow to instantiate current object instance. In case you extended <code>Ticket</code>,
you will obtain here the last-in-chain class type.</em></p>

<h2 id="advantages-and...-advantages">Advantages and... advantages</h2>

<p>Not really drawbacks here, let's focus on the advantages</p>

<h3 id="%C2%A0nice-semantics"> Nice semantics</h3>

<p><code>$ticket = Ticket::fromTitle('new title')</code> speaks for itself. More than creating an instance, you <strong>describe the
intent</strong> which is a key part in complex applications.</p>

<h3 id="override-constructors">Override constructors</h3>

<p>Unlike other languages (such as C++) , <strong>PHP can only have one constructor per class</strong>. If you stick to your class 
to get an instance, the only way to fulfill different instance creation scenarii is to:</p>

<ul>
<li>Low the signature exigence (parameters type-hinting, nullable,...)</li>
<li>Creates several checks and tests to ensure params passed on creation are still consistent</li>
</ul>

<p>As named constructors are simple static methods, and considering the fact that <code>__construct()</code> is no more available 
from outside world, you can create <strong>as much named constructors as you want</strong>. And guess what ?</p>

<ul>
<li>Design intents are still here (<code>Ticket::fromTitle()</code>, <code>Ticket::fromAnotherTicket()</code>...).</li>
<li>All coherence checks are separated and lies only in named constructor they belong to.</li>
</ul>

<p>Last but not least, this is totally <strong>framework agnostic</strong>. You can start using them now, with nothing but
intention.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony Workflow component - part 1]]></title>
            <link href="/blog/2020/03/02/symfony-workflow-component-walkthrough-part-1/"/>
            <updated>2020-03-02T13:30:00+01:00</updated>
            <id>/blog/2020/03/02/symfony-workflow-component-walkthrough-part-1/</id>
            <content type="html"><![CDATA[<p>The <a href="https://symfony.com/doc/current/components/workflow.html">Symfony Workflow component</a>, according to documentation,
allows to :</p>

<blockquote>
  <p>The Workflow component provides tools for managing a workflow or finite state machine.</p>
</blockquote>

<p>This one-line program can be breathtaking, when we measure the complexity the task can be.
This feeling passed away, let's see how this implementation can drastically help us to enforce some rules defined by 
<strong>places</strong> &amp; <strong>transitions</strong>.</p>

<p>As a reminder (from doc again), a workflow is</p>

<blockquote>
  <p>A way to define a process or a life cycle that your object goes through.</p>
</blockquote>

<h2 id="2-types-of-workflows">2 types of workflows</h2>

<p>There are 2 ways : <strong>workflow</strong> or <strong>finite state machine</strong>. Main difference is <strong>workflow allows subject to take simultaneous 
states as the same time</strong>, whereas finite state machine authorize <strong>only one at a time</strong>. This post focuses on the latter.
As a start, the finite state machine is easier to deal with.</p>

<h3 id="vocabulary">Vocabulary</h3>

<p>Let's define vocabulary first :</p>

<ul>
<li><strong>Place</strong> : given state marking the object status (for example "Draft", "Published", "Review"...).</li>
<li><strong>Transition</strong> : named action for moving from one place to another (for example "Publication" 
will drag the state marker from place "Draft" to place "Publish").</li>
<li><strong>Definition</strong> : set of places and transitions</li>
</ul>

<p>Let's focus on a classical ticket system, like Redmine. A workflow definition (simplified) could be :</p>

<p><img src="https://devgiants.fr/images/posts/workflow/ticket_workflow_example.png" alt="Ticket workflow example" /></p>

<p>We now have a definition. Let's transcript this in configuration :</p>

<p><kbd>workflow.yaml</kbd></p>

<pre><code class="yaml">framework:
  workflows:
    ticket:
      # Only one state at a time for target entities
      type: 'state_machine'

      # Make log trail cruise
      #      audit_trail:
      #        enabled: true
      marking_store:
        type: 'method'
        property: 'state'
      supports:
        - App\Entity\Ticket
      initial_marking: !php/const App\Workflow\Status\TicketStatuses::NEW
      places:
        - !php/const App\Workflow\Status\TicketStatuses::NEW
        - !php/const App\Workflow\Status\TicketStatuses::IN_PROGRESS
        - !php/const App\Workflow\Status\TicketStatuses::COMMENT
        - !php/const App\Workflow\Status\TicketStatuses::SOLVED
        - !php/const App\Workflow\Status\TicketStatuses::CLOSED
      transitions:
        !php/const App\Workflow\Transition\TicketTransitions::START_PROCESS:
          from:
            - !php/const App\Workflow\Status\TicketStatuses::NEW
            - !php/const App\Workflow\Status\TicketStatuses::COMMENT
          to: !php/const App\Workflow\Status\TicketStatuses::IN_PROGRESS
        !php/const App\Workflow\Transition\TicketTransitions::COMMENT:
          from: !php/const App\Workflow\Status\TicketStatuses::IN_PROGRESS
          to:   !php/const App\Workflow\Status\TicketStatuses::COMMENT
        !php/const App\Workflow\Transition\TicketTransitions::SOLVE:
          from: !php/const App\Workflow\Status\TicketStatuses::IN_PROGRESS
          to:   !php/const App\Workflow\Status\TicketStatuses::SOLVED
        !php/const App\Workflow\Transition\TicketTransitions::UNSOLVE:
          from: !php/const App\Workflow\Status\TicketStatuses::SOLVED
          to:   !php/const App\Workflow\Status\TicketStatuses::IN_PROGRESS
        !php/const App\Workflow\Transition\TicketTransitions::CLOSE:
          from: !php/const App\Workflow\Status\TicketStatuses::SOLVED
          to:   !php/const App\Workflow\Status\TicketStatuses::CLOSED
</code></pre>

<p><kbd>App\Workflow\Transition\TicketTransitions</kbd></p>

<pre><code class="php">&lt;?php

namespace App\Workflow\Transition;


final class TicketTransitions
{
    public const START_PROCESS = 'start_process';
    public const COMMENT = 'comment';
    public const SOLVE = 'solve';
    public const UNSOLVE = 'unsolve';
    public const CLOSE = 'close';
}
</code></pre>

<p><kbd>App\Workflow\Status\TicketStatuses</kbd></p>

<pre><code class="php">&lt;?php

namespace App\Workflow\Status;


final class TicketStatuses
{
    public const NEW = 'new';
    public const IN_PROGRESS = 'in_progress';
    public const COMMENT = 'comment';
    public const SOLVED = 'solved';
    public const CLOSED = 'closed';
}
</code></pre>

<p>You may note the heavy use of YAML PHP constant. YAML is therefore a bit less readable, but this allow to define in a clear way things in PHP 
and use them in YAML files. Coupling usage with Doctrine Enumerations (for example <a href="https://github.com/fre5h/DoctrineEnumBundle">DoctrineEnumBundle</a>) is good practice.</p>

<p><a href="https://symfony.com/doc/current/workflow.html#creating-a-workflow">Documentation</a> goes through keys and values expected regarding to this configuration.</p>

<h2 id="the-marking-store">The marking store</h2>

<p>I redefined on purpose the following part:</p>

<p><kbd>workflow.yaml</kbd></p>

<pre><code class="yaml">      marking_store:
        type: 'method'
        property: 'state'
</code></pre>

<p>The <code>property</code> key contains the entity attribute that will carry the state (the place)
the entity is. A <a href="https://symfony.com/blog/new-in-symfony-4-3-workflow-improvements">quite recent move</a> from core team 
introduce few things, especially <a href="https://symfony.com/blog/new-in-symfony-4-3-workflow-improvements#added-a-context-to-workflow-apply">context data</a> that can be useful.</p>

<p>So the <code>Ticket</code> entity will look like :</p>

<pre><code class="php">&lt;?php

namespace App\Entity;

use App\Behavior\Workflowable;
use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\Common\Collections\Collection;
use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity(repositoryClass="App\Repository\TicketRepository")
 */
class Ticket
{
    use Workflowable;

    /**
     * @ORM\Id()
     * @ORM\GeneratedValue()
     * @ORM\Column(type="integer")
     */
    protected $id;

    /**
     * @ORM\Column(type="string", length=255)
     */
    protected $title;

    /**
     * @ORM\ManyToOne(targetEntity="App\Entity\Ticket", inversedBy="relatedTickets")
     */
    protected $parentTicket;

    /**
     * @ORM\OneToMany(targetEntity="App\Entity\Ticket", mappedBy="parentTicket")
     */
    protected $relatedTickets;

    public function __construct()
    {
        $this-&gt;relatedTickets = new ArrayCollection();
    }

    public function getId(): ?int
    {
        return $this-&gt;id;
    }

    public function getTitle(): ?string
    {
        return $this-&gt;title;
    }

    public function setTitle(string $title): self
    {
        $this-&gt;title = $title;

        return $this;
    }

    public function getParentTicket(): ?self
    {
        return $this-&gt;parentTicket;
    }

    public function setParentTicket(?self $parentTicket): self
    {
        $this-&gt;parentTicket = $parentTicket;

        return $this;
    }

    /**
     * @return Collection|self[]
     */
    public function getRelatedTickets(): Collection
    {
        return $this-&gt;relatedTickets;
    }

    public function addRelatedTicket(self $relatedTicket): self
    {
        if (!$this-&gt;relatedTickets-&gt;contains($relatedTicket)) {
            $this-&gt;relatedTickets[] = $relatedTicket;
            $relatedTicket-&gt;setParentTicket($this);
        }

        return $this;
    }

    public function removeRelatedTicket(self $relatedTicket): self
    {
        if ($this-&gt;relatedTickets-&gt;contains($relatedTicket)) {
            $this-&gt;relatedTickets-&gt;removeElement($relatedTicket);
            // set the owning side to null (unless already changed)
            if ($relatedTicket-&gt;getParentTicket() === $this) {
                $relatedTicket-&gt;setParentTicket(null);
            }
        }

        return $this;
    }
}
</code></pre>

<p>You may note the trait <code>Workflowable</code>. All finite state machine will have the same attribute for carrying place,
so it can be DRYed like that :</p>

<pre><code class="php">&lt;?php


namespace App\Behavior;


trait Workflowable
{
    /**
     * @ORM\Column(type="string", length=15, nullable=false)
     *
     * @var string
     */
    protected $state;

    /**
     * @return string
     */
    public function getState(): ?string
    {
        return $this-&gt;state;
    }

    /**
     * @param string $state
     *
     * @return Workflowable
     */
    public function setState(string $state,  $context = []): self
    {
        $this-&gt;state = $state;

        return $this;
    }
}
</code></pre>

<h2 id="what-can-you-do-with-this-%3F">What can you do with this ?</h2>

<p>That being said, how can you lever the definition you just made ? Let's create a ticket and make a cruise :
The example is given in a controller for DI simplicy and easy access sake, but let's keep in mind that must not be done
in real projects (Single Responsability Principle, not for controller).</p>

<pre><code class="php">public function index(Registry $registry)
    {
        /*****************************************
         * Simple example
         */
        // Create new ticket
        $ticket = new Ticket();
        $ticket-&gt;setTitle('Nice title');

        // Find workflow by entity
        // Will throw an exception if a same entity is targeted by multiple workflows
        // unless you provide second argument
        $ticketWorkflow = $registry-&gt;get($ticket);

        // Apply transition
        // Will try to play the transition (move from A place to B place) on the given entity 
        $ticketWorkflow-&gt;apply($ticket, TicketTransitions::START_PROCESS);

        return $this-&gt;render('main.html.twig');
    }
</code></pre>

<p>The <code>apply</code> method will try to play transition for changing given entity state. 2 possibilities from here :</p>

<h3 id="given-transition-is-applyable">Given transition is applyable</h3>

<p>it means that transition <code>from</code> places contains actual entity state.</p>

<p><em>Example : as stated in configuration, initial marking for <code>Ticket</code> entity is <code>TicketStatuses::NEW</code> place. 
Quick_look to configuration confirms that this place is allowed as start place for TicketTransitions::START_PROCESS</em></p>

<p>The workflow given above is dead simple, but as most of you have noticed, <strong>you may specify more than one start place</strong>.
The opposite is not possible because you wouldn't know which place to pick up once transition done.</p>

<h3 id="given-transition-is-not-applyable">Given transition is not applyable</h3>

<p>The opposite from above. You can't apply this transition. If you try it, a <code>LogicException</code> will be raised :</p>

<h3 id="some-reflection">Some reflection</h3>

<p>For adding dynamism, you can make <strong>some reflection on workflow object</strong>. You can :</p>

<ul>
<li>Check if given entity can do transition : <code>$ticketWorkflow-&gt;can($ticket, TicketTransitions::START_PROCESS)</code></li>
<li>Retrieve available transitions for given entity : <code>$ticketWorkflow-&gt;getEnabledTransitions($ticket)</code></li>
</ul>

<p>Those 2 helpers are immensively useful, because <strong>you can safely make your object cruising according to runtime data</strong>.</p>

<h2 id="quick-conclusion">Quick conclusion</h2>

<p>I hope you realize how powerful this structure is and how it can help to strenghten you business rules,
by constraining entities to planned cruise during its lifetime.</p>

<p>Next post will focus on the real stuff : events dispatched by the system that will allow you to 
do the serious things.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Domofony Symfony application - part 1]]></title>
            <link href="/blog/2019/10/13/domofony-symfony-application/"/>
            <updated>2019-10-13T11:30:00+02:00</updated>
            <id>/blog/2019/10/13/domofony-symfony-application/</id>
            <content type="html"><![CDATA[<p>This post presents some implementation &amp; architecture choices made for achieving previous exposed goal in <strong>home automation
platform development wich would be focus on code and yaml configuration</strong>.</p>

<p><img src="https://devgiants.fr/images/posts/domofony/technical_components_with_items.png" alt="Technical components" /></p>

<h2 id="items">Items</h2>

<p>As stated in <a href="https://devgiants.fr/blog/2019/10/12/domofony-presentation/">previous post</a>, items are the <strong>end-of-chain component</strong>, 
but also the most important part of this very chain (from home automation point-of-view): 
temperature sensor, switch, relay, devices with all of this... 
Actuators like switches will handle orders they receive through the MQTT bus (by listening on correct channels), 
while sensors will publish their data on time on the same bus. As central system <a href="https://github.com/devgiants/domofony/blob/master/src/Command/MainMQTTLoopCommand.php#L62">will listen to all channels</a>, 
it will have the capability to <strong>trigger good code portions regarding to what happens</strong>.</p>

<p>According to what explained above, <code>Item</code> does not deserve the Entity status. 
Each item will require code, that will lie on <code>ItemHandler</code>. 
So just add it as a record line in database is irrelevant.</p>

<p>That's why I decided the best way IMHO to declare and describe an <code>Item</code> was by <code>yaml</code> configuration. Here is a typical
declaration :</p>

<p><strong>config/services.yaml</strong></p>

<pre><code class="yaml">    items:
        west_wall_shutter_1:                        # The item ID
            handler: App\ItemHandler\TestHandler    # The handler FQCN
            api:                                    # API configuration
                accepted_arguments:                 # Accepted arguments
                    - open
                    - close
</code></pre>

<p>The item ID will be used as query parameter when invoking API <code>Item</code> endpoint (see below).</p>

<h2 id="items-handlers">Items handlers</h2>

<p>This application have to let you develop the behavior you want while providing you the context needed to take home automation decisions. 
So the goals are :</p>

<ul>
<li><strong>Let you write code within the application</strong> : only the code the application can't provide so <strong>your home automation code only</strong>.</li>
<li><strong>Automatic insertion</strong> of your custom code in application architecture. Neither complex configuration nor manual inclusion.</li>
</ul>

<h3 id="handler-creation">Handler creation</h3>

<p><strong>App\ItemHandler\TestHandler</strong></p>

<pre><code class="php">class TestHandler implements ItemHandlerInterface
{
    public function __invoke(array $payload, RequestInterface $request)
        {
            // TODO: Implement __invoke() method, using parameters
        }
}
</code></pre>

<p>Each <code>ItemHandler</code> must implements <code>ItemHandlerInterface</code>, so it will be recognized as real item handler. 
The handler FQCN will be the same as the one used in above configuration.</p>

<p>The payload is the one given when item update endpoint is consumed. The request is the classical HttpFoundation <code>Request</code>
object, in case you need more than payload to get context for your item handling.</p>

<h3 id="item-handler-tagging">Item handler tagging</h3>

<p>In order to make it work out-of-the-box without manual service registration, <strong>automatic service tagging</strong> is used :</p>

<p><strong>config/services.yaml</strong></p>

<pre><code class="yaml">services:
   #...

    _instanceof:
        App\Model\ItemHandlerInterface:
            tags: ['app.item_handler']
            lazy: true
</code></pre>

<p>Above configuration will add <code>app.item_handler</code> tag <strong>automatically to all classes implementing <code>App\Model\ItemHandlerInterface</code></strong></p>

<p>Next, <a href="https://symfony.com/blog/new-in-symfony-3-4-simpler-injection-of-tagged-services">quite recent feature from Symfony 3.4</a> allow to <strong>locate and collect all those tagged services to pass them as argument</strong> :</p>

<p><strong>config/services.yaml</strong></p>

<pre><code class="yaml">services:
    App\Controller\ItemUpdateController:
        arguments: [!tagged app.item_handler]
</code></pre>

<p>The argument got here is an <code>ìterable</code> :</p>

<p><strong>App\Controller\ItemUpdateController</strong></p>

<pre><code class="php">/**
 * Class ItemUpdateController
 *
 * @package App\Controller
 */
class ItemUpdateController extends AbstractController
{

    /**
     * @var iterable $itemHandlers
     */
    protected $itemHandlers;

    /**
     * ItemUpdateController constructor.
     *
     * @param iterable $itemHandlers
     */
    public function __construct(
        iterable $itemHandlers
    ) {
        $this-&gt;itemHandlers    = $itemHandlers;
    }

    // ....

}
</code></pre>

<p><em>Note : only relevant arguments are kept here, for sake of brevity. Complete file <a href="https://github.com/devgiants/domofony/blob/master/src/Controller/ItemUpdateController.php">here</a>.</em></p>

<h3 id="item-updater-behind-the-scene">Item updater behind the scene</h3>

<p>Now, we just have to invoke the matching item handler. This is done when <code>ItemUpdateController</code> is itself invoked :</p>

<p><strong>App\Controller\ItemUpdateController</strong></p>

<pre><code class="php">class ItemUpdateController extends AbstractController
{
    public function __invoke(
        string $id,
        RequestStack $requestStack,
        ItemFinder $itemFinder
    ) {
        // Find item
        $item = $itemFinder-&gt;findById($id);

        // Extract and create handler instance
        $handlerFQCN = $item-&gt;getHandlerFQCN();

        if ( ! class_exists($handlerFQCN)) {
            throw new ClassNotFoundException();
        }

        foreach ($this-&gt;itemHandlers as $itemHandler) {
            // If handler found, extract payload and invoke it
            if ($itemHandler instanceof $handlerFQCN) {
                $request = $requestStack-&gt;getCurrentRequest();
                $payload = json_decode($request-&gt;getContent());

                // Pre handler event
                $preHandlerEvent = new PreHandlerCallEvent($item, $payload,
                    $request);
                $this-&gt;eventDispatcher-&gt;dispatch($preHandlerEvent);

                // Item handler invocation
                call_user_func($itemHandler, $preHandlerEvent-&gt;getPayload(),
                    $preHandlerEvent-&gt;getRequest());

                // Post handler event
                $postHandlerEvent = new PostHandlerCallEvent($preHandlerEvent-&gt;getItem(),
                    $preHandlerEvent-&gt;getPayload(),
                    $preHandlerEvent-&gt;getRequest());
                $this-&gt;eventDispatcher-&gt;dispatch($preHandlerEvent);

                return $postHandlerEvent-&gt;getItem();
            }
        }

        return $item;
    }
}
</code></pre>

<p><em>Note : only relevant code is kept here, for sake of brevity. Complete file <a href="https://github.com/devgiants/domofony/blob/master/src/Controller/ItemUpdateController.php">here</a>.</em></p>

<h2 id="api-usage">API usage</h2>

<p>The application exposes an <code>Item</code> API, used for retrieving item state (<code>GET</code>), and also send updates (<code>PUT</code>).</p>

<p>Reusing <code>Ìtem</code> example configured above, REST requests endpoint would be <code>http://mydomain.com/api/item/west_wall_shutter_1</code>.</p>

<p>API part is handled by wonderful <a href="https://api-platform.com/">API Plaftorm</a>. As stated in first part of this post, 
I ended up to the fact that <code>Item</code> ar not real entity. As I treated them with yaml configuration, 
I needed <strong>custom DataProvider allowed by API Platform for retrieving data that are not in Doctrine</strong>:</p>

<p><strong>App\DataProvider\ItemDataProvider</strong></p>

<pre><code class="php">namespace App\DataProvider;

use ApiPlatform\Core\DataProvider\ItemDataProviderInterface;
use ApiPlatform\Core\DataProvider\RestrictedDataProviderInterface;
use App\Model\Item;
use App\Service\ItemFinder;

/**
 * Class ItemDataProvider
 *
 * @package App\DataProvider
 */
final class ItemDataProvider implements ItemDataProviderInterface, RestrictedDataProviderInterface
{

    /**
     * @var ItemFinder
     */
    protected $itemFinder;

    /**
     * ItemDataProvider constructor.
     *
     * @param ItemFinder $itemFinder
     */
    public function __construct(ItemFinder $itemFinder)
    {
        $this-&gt;itemFinder = $itemFinder;
    }

    /**
     * @inheritDoc
     */
    public function supports(
        string $resourceClass,
        string $operationName = null,
        array $context = []
    ): bool {
        return Item::class === $resourceClass;
    }

    /**
     * @inheritDoc
     */
    public function getItem(
        string $resourceClass,
        $id,
        string $operationName = null,
        array $context = []
    ) {
        return $this-&gt;itemFinder-&gt;findById($id);
    }
}
</code></pre>

<p>This <code>DataProvider</code> relies on an <code>ItemFinder</code> service that have access to the <code>items</code> declared in configuration.</p>

<p>API configuration misses now specific route configuration, as we got out of the normal CRUD scope.</p>

<p>This is done here for ItemGetterController (<code>GET</code> requests) :</p>

<p><strong>App\Controller\ItemGetterController</strong></p>

<pre><code class="php">namespace App\Controller;

use App\Service\ItemFinder;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\Routing\Annotation\Route;
use App\Model\Item;

/**
 * Class ItemGetterController
 *
 * @package App\Controller
 */
class ItemGetterController extends AbstractController
{
    /**
     * @Route(
     *     name="devgiants.domofony.item.get",
     *     path="/api/item/{id}",
     *     methods={"GET"},
     *     defaults={
     *       "_api_resource_class": "App\Model\Item",
     *       "_api_item_operation_name": "get"
     *     }
     * )
     *
     * @param string $id
     * @param ItemFinder $itemFinder
     * @return Item
     */
    public function __invoke(string $id, ItemFinder $itemFinder)
    {
        return $itemFinder-&gt;findById($id);
    }
}
</code></pre>

<p>And the same stands for <code>ItemUpdateController</code> :</p>

<p><strong>App\Controller\ItemUpdateController</strong></p>

<pre><code class="php">/**
 * Class ItemUpdateController
 *
 * @package App\Controller
 */
class ItemUpdateController extends AbstractController
{
    /**
     * @Route(
     *     name="devgiants.domofony.item.update",
     *     path="/api/item/{id}",
     *     methods={"PUT"},
     *     defaults={
     *       "_api_resource_class": "App\Model\Item",
     *       "_api_item_operation_name": "put"
     *     }
     * )
     *
     * @param string $id
     * @param RequestStack $requestStack
     * @param ItemFinder $itemFinder
     *
     * @return Item
     * @throws ClassNotFoundException
     */
    public function __invoke(
        string $id,
        RequestStack $requestStack,
        ItemFinder $itemFinder
    ) {
        // ...
    }
}
</code></pre>

<h2 id="bundle-versus-application">Bundle versus application</h2>

<p>At start, I wanted to make a bundle, that can be plugged onto any other application. 
I quickly realized that <strong>required specific configuration</strong> and <strong>above-described architecture</strong> 
needed <strong>a complete boilerplate application</strong>, that will be installable with a <code>composer create-project</code> command.</p>

<p>Furthermore, this app business purpose makes it quite exclusive regarding usage : it will be used only for home 
automation context and <strong>it's highly improbable that it will be added to other existing application</strong>.</p>

<h3 id="application-custom-extension">Application custom extension</h3>

<p>In order to be able to use custom configuration namespace, and trigger configuration checks, <strong>I registered a custom extension 
within the application itself</strong> (this configuration usually lies on bundle). This is done by manually registering the
extension in <code>Kernel</code> :</p>

<p><strong>App\Kernel</strong></p>

<pre><code class="php">class Kernel extends BaseKernel
{
    protected function configureContainer(ContainerBuilder $container, LoaderInterface $loader)
    {
        $devgiantsDomofonyExtension = new DevgiantsDomofonyExtension();

        $container
            -&gt;addResource(new FileResource($this-&gt;getProjectDir().'/config/bundles.php'))
            // Register extension to make configuration working
            -&gt;registerExtension($devgiantsDomofonyExtension)
        ;
        // ...
    }
}
</code></pre>

<p>We are done here with specific implementations that required enlightments. 
Next post will be dedicated to the <strong>security part</strong> and <strong>MQTT loop command</strong>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Domofony presentation]]></title>
            <link href="/blog/2019/10/12/domofony-presentation/"/>
            <updated>2019-10-12T14:51:00+02:00</updated>
            <id>/blog/2019/10/12/domofony-presentation/</id>
            <content type="html"><![CDATA[<h2 id="home-automation">Home automation</h2>

<p>On my previous attempts on DIY home automation, I used the excellent <a href="https://www.openhab.org/">openHAB</a>.
At first glance, it seemed to have everything I looked for in an home automation context :</p>

<ul>
<li>Completely open-source</li>
<li><strong>Technology and vendor agnostic</strong> : one of the most important thing, I didn't want to rely on proprietary technology to build this system. Everything has to be transparent from ground to roof, and modifiable to ensure long-term usage and adaptation</li>
<li><strong>Ability to program for serious work</strong> : it's utterly important to me that real programmation feature would be available. Way I do things doesn't match with a click-land configuration job. Using <a href="https://www.eclipse.org/xtend/">Xtend</a> (because openHAB written in Java), it allows to create programs to drive your installation.</li>
</ul>

<p>So why change? Some cons :</p>

<ul>
<li>I realized after usage that all the stuff embedded (item branching with technologies, configuration...) simply wasn't for me</li>
<li>Xtend implementation in this usage, though really neat, does not allow things I wanted (such as script reuse accross handlers...)</li>
<li>All the Java stuff creates pressure on underlying hardware, thus forcing to have something powerful (old Raspberry Pis was not so good)</li>
</ul>

<p>Don't misunderstand me : OpenHAB is great job used y thousand of people accross the world. I just needed something else.</p>

<h2 id="domofony">Domofony</h2>

<p><em>Domotique</em> + <em>Symfony</em> = <a href="https://github.com/devgiants/domofony"><strong>Domofony</strong></a>.</p>

<p><em>Domotique</em> is the french word for home automation. First thing to know, I created this project for myself, and share it a good practice, but at start, not all things will be usable by everyone (such as the front-end app I plan to develop tailored to my use).</p>

<p><strong>This is a solution provided by a developer for developers</strong>. Exit click-land, all configuration is done in YAML.</p>

<h3 id="technical-components">Technical components</h3>

<p><img src="https://devgiants.fr/images/posts/domofony/technical_components_with_items.png" alt="Technical components" /></p>

<p>All part showed on above layout will be described and detailed in future posts. That being said, below is a quick description for bigger parts.</p>

<h4 id="front-end-application">Front-end application</h4>

<p>This is the application allowing user to interact with the system. It will consume REST API exposed by the server application.</p>

<h4 id="mosquitto-broker">Mosquitto broker</h4>

<p>The system relies so far on <a href="https://en.wikipedia.org/wiki/MQTT">MQTT protocol</a> 
(<a href="https://www.linkedin.com/pulse/mqtt-un-protocole-bas%C3%A9-sur-tcp-et-orient%C3%A9-iot-nicolas-bonniot/">here</a> a protocol tour in french) for exchanges between <strong>central system</strong> and <strong>items</strong>.
This protocol is ideal regarding it's asynchronous sequence and its lightweight. 
Security is not left aside, although TLS certificate usage means items must be more powerful than simple microcontrollers.</p>

<p><em>Note : an item is the end-device, such as sensor or actuator (or both). In my home automation system, this is mostly <a href="https://en.wikipedia.org/wiki/Single-board_computer">SBC</a> or ESP series microcontrollers</em></p>

<p>Future posts will handle in details <strong>items</strong>, <strong>Symfony application</strong>, <strong>Mosquitto broker &amp; client configuration</strong> and <strong>front-end application</strong>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[API versionning strategies]]></title>
            <link href="/blog/2018/12/11/api-versionning/"/>
            <updated>2018-12-11T17:04:00+01:00</updated>
            <id>/blog/2018/12/11/api-versionning/</id>
            <content type="html"><![CDATA[<h2 id="context">Context</h2>

<p>API are like any other programmed systems : they evolve during time, either with bugfixes or feature addition. There is a roadmap that can eventually bring to a <strong>backward compatibility break</strong> to ensure proper evolution regarding new features.</p>

<h2 id="versionning">Versionning</h2>

<p>Versionning is important, mainly to provide your API clients ways to ensure they use the proper version regarding their needs.</p>

<p>Few ways : 
 - Domain name : <code>https://v4.your-api.com</code>
 - URI prefix : <code>https://your-api.com/api/v4</code>
 - Query string : <code>https://your-api.com/api/?v=4.0.0</code>
 - Custom HTTP header : <code>X-API-Version: 4.0.0</code>
 - <code>Accept</code> HTTP header :  <code>Accept: application/vendor.app.your-app+json; version=4.0.0</code></p>

<p>Keep as the rule of thumb than changing URLs are <strong>generally bad idea</strong>. HTTP headers are the way to go. Below is a configuration possibility for the <code>Accept</code> header.</p>

<h2 id="fosrestbundle-configuration-for-%60accept%60-header">FOSRestBundle configuration for <code>Accept</code> header</h2>

<p>2 keys to add to FOSRestBundle configuration : <code>versionning</code> and <code>view:meme_types</code></p>

<h3 id="versionning">Versionning</h3>

<p>You need to tell FOSRestBundle you are using versionning in your app :</p>

<pre><code class="yaml">fos_rest:
  ...
  versioning:
    enabled: true
    resolvers:
      media_type: # Accept header
        enabled: true
        regex: '/(v|version)=(?P&lt;version&gt;[0-9\.]+)/'
</code></pre>

<p>Of course, you an freely adapt the regex to your needs.</p>

<h3 id="add-mime-type">Add MIME type</h3>

<p>As you can see above, the MIME type you send is now custom (<code>application/vendor.app.your-app+json; version=4.0.0</code>). You need to tell FOSRestBundle to accept it :</p>

<pre><code class="yaml">fos_rest:
  ...
  view:
    ...    
    mime_types:
      json: ['application/json', 'application/json;version=1.0', 'application/json;version=2.0']
</code></pre>

<p>For the sake of brevity, I just put the matching configurations key with <code>Accept</code> header.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[FOS REST Bundle : enforce strict behavior with query params requirements]]></title>
            <link href="/blog/2018/11/16/fos-rest-query-param-strict/"/>
            <updated>2018-11-16T17:15:00+01:00</updated>
            <id>/blog/2018/11/16/fos-rest-query-param-strict/</id>
            <content type="html"><![CDATA[<h2 id="context">Context</h2>

<p>Playing with <a href="https://github.com/FriendsOfSymfony/FOSRestBundle">FOS REST Bundle</a> on my journey to learn how to create rock-solid APIs, I started to create following action :</p>

<pre><code class="php">/**
     * @param PostHandler $postHandler
     * @param ParamFetcherInterface $paramFetcher
     * @Rest\Get("/posts/list")
     * @Rest\QueryParam(
     *     name="keyword",
     *     requirements="[a-zA-Z0-9]*",     
     *     nullable=true,
     *     description="The keyword to search for."
     * )
     * @Rest\QueryParam(
     *     name="order",
     *     requirements="asc|desc",
     *     default="asc",     
     *     description="Sort order (asc or desc)"
     * )
     * @Rest\QueryParam(
     *     name="limit",
     *     requirements="\d+",
     *     default="3",     
     *     description="Max number of posts per page."
     * )
     * @Rest\QueryParam(
     *     name="page",
     *     requirements="\d+",
     *     default="1",     
     *     description="The page wanted"
     * )
     * @Rest\View(
     *     statusCode = 200,
     *     serializerGroups = {"list"}
     * )
     *
     * @return Paginator
     */
    public function list(PostHandler $postHandler, ParamFetcherInterface $paramFetcher)
    {


        $postsList = $postHandler-&gt;search(
            intval($paramFetcher-&gt;get('limit')),
            intval($paramFetcher-&gt;get('page')),
            $paramFetcher-&gt;get('order'),
            $paramFetcher-&gt;get('keyword')
        );

        return $postsList;
    }
</code></pre>

<p>This simply expose a GET endpoint, with URL <code>/posts/list</code>, in order to return a... posts list. Several <code>QueryParam</code> can be passed in order to filter the obtained list. So, according to requirements given, following calls are acceptable (and processed) :
- <code>/posts/list?page=2</code> to get page 2, with default <code>limit</code>
- <code>/posts/list?order=desc</code> to order posts by ID descendant
- <code>/posts/list?keyword=test</code> to retrieves only posts with 'test' keyword.</p>

<h2 id="what-if...-we-don%27t-follow-requirements-%3F">What if... we don't follow requirements ?</h2>

<p>For each <code>QueryParam</code>, requirements are given in <a href="https://symfony.com/doc/current/routing/conditions.html">an regexp way</a>. Actually, requirements annotations are compiled to PHP. So, if I try :</p>

<ul>
<li><code>/posts/list?page=a</code></li>
<li><code>/posts/list?order=other</code></li>
<li><code>/posts/list?keyword=test%20test2</code></li>
</ul>

<p>What will happen? Nothing. By default, FOS REST Bundle will take <strong>the offending <code>QueryParam</code> default value instead</strong> of your offending value.</p>

<h2 id="what-if-we-want-to-raise-an-error%3F">What if we want to raise an error?</h2>

<p>Depending to which <code>QueryParam</code> you deal with, you may want to raise an error or not. For the above example, client developers will love you if you provide explicit errors and comprehensive messages for those <code>QueryParam</code>. The solution for that is simple : just add the <code>QueryParam</code> attribute <code>strict</code> to true in order to force FOS REST Bundle to raise an Exception.
With proper configuration (such as <code>ExceptionController</code>), you achieve to throw out-of-the-box exceptions like this :</p>

<pre><code>GET http://localhost:8081/posts/list?page=a

HTTP/1.1 400 Bad Request
Date: Fri, 16 Nov 2018 16:34:15 GMT
Server: Apache/2.4.18 (Ubuntu)
Cache-Control: no-cache, private
X-Debug-Token: 34ff9b
X-Debug-Token-Link: http://localhost:8081/_profiler/34ff9b
X-Previous-Debug-Token: fd05dc
Connection: close
Transfer-Encoding: chunked
Content-Type: application/json

{
  "error": "Parameter \"page\" of value \"a\" violated a constraint \"Parameter 'page' value, does not match requirements '\\d+'\""
}

Response code: 400 (Bad Request); Time: 4106ms; Content length: 137 bytes
</code></pre>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Composer usage can also be global]]></title>
            <link href="/blog/2018/11/15/composer-global/"/>
            <updated>2018-11-15T10:00:00+01:00</updated>
            <id>/blog/2018/11/15/composer-global/</id>
            <content type="html"><![CDATA[<p>As an every-day <a href="https://getcomposer.org">Composer</a> user, I always used it on a project scope, i.e with a <code>composer.json</code> lying in a specific project directory.
I discover recently than it can also be used on a <a href="https://getcomposer.org/doc/03-cli.md#global">global way</a> (meaning not related to a project) using <code>global</code> modifier:</p>

<pre><code>composer global require squizlabs/php_codesniffer
</code></pre>

<p>The globally installed package will be accessible user-system wide. On my Ubuntu system, global <code>vendor</code> folder lies on <code>~/.config/composer/</code>.</p>

<p>It strikes me yesterday that this feature is exactly the same one which is provided by <code>npm</code>, <code>yarn</code> or <code>bower</code>, other packages/dependencies manager.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Introduce React PHP]]></title>
            <link href="/blog/2018/05/21/react-php/"/>
            <updated>2018-05-21T12:00:00+02:00</updated>
            <id>/blog/2018/05/21/react-php/</id>
            <content type="html"><![CDATA[<h2 id="context">Context</h2>

<p>On a recent Angular 5 training I could luckily attend to, trainer introduces JS reactive programming (using <a href="https://beta-rxjsdocs.firebaseapp.com/">RXJS</a>). Complete new paradigm as everything is event, nested one with others. 
Way different way to code... But extremely powerful.</p>

<p>Then I tought : what a wonderful way to stick to my home automation real life modeling. As a matter of fact, IoT and home automation are mainly composed of <strong>stimuli</strong> and <strong>reactions</strong>.</p>

<p>What could be better in this context than reactive loop to events? That's what lead me to <a href="https://reactphp.org/">ReactPHP</a>, which is a PHP implementation of <a href="https://fr.wikipedia.org/wiki/Reactor">Reactor pattern</a>.
This library is very well-done, concern separated.</p>

<h2 id="few-examples">Few examples</h2>

<h3 id="main-brick-%3A-event-loop">Main brick : <a href="https://github.com/reactphp/event-loop">event-loop</a></h3>

<h4 id="factory-for-loop-object-creation">Factory for loop object creation</h4>

<pre><code class="php">$loop = React\EventLoop\Factory::create();
</code></pre>

<p>Behind the scenes, this named constructor will use the best scenario according to your configuration.</p>

<pre><code class="php">  public static function create()
    {
        // @codeCoverageIgnoreStart
        if (class_exists('libev\EventLoop', false)) {
            return new ExtLibevLoop();
        } elseif (class_exists('EvLoop', false)) {
            return new ExtEvLoop();
        } elseif (class_exists('EventBase', false)) {
            return new ExtEventLoop();
        } elseif (function_exists('event_base_new') &amp;&amp; PHP_VERSION_ID &lt; 70000) {
            // only use ext-libevent on PHP &lt; 7 for now
            return new ExtLibeventLoop();
        }
        return new StreamSelectLoop();
        // @codeCoverageIgnoreEnd
    }
</code></pre>

<p>More details on differents implementations and extensions related <a href="https://github.com/reactphp/event-loop#loop-implementations">here</a>. So far I'm using the fallback one (StreamSelect) but will enhance this point soon.</p>

<h4 id="loop-run">Loop run</h4>

<pre><code class="php">$loop-&gt;run();
</code></pre>

<p>Short and sweet. This must be the script last instruction because it will enter in infinite loop from here.</p>

<h4 id="timers">Timers</h4>

<p>```php
 $loop->addTimer(0.8, function () {
     echo 'world!' . PHP_EOL;
 });</p>

<p>$loop->addTimer(0.3, function () {
     echo 'hello ';
 });
 $loop->run();
 ```</p>

<p>Here start the magic. The above script will echo 'hello' 0.3s after script beginning then 'world' at 0.5s (0.8s from start). No matter timer registration order, loop will handle orders.
 Thanks to closures/callbacks, you can put your processes inline for shortness.</p>

<p><em>Note: you can (and certainly will) use the <code>use</code> keyword to port any variables in the callback code block context</em>.</p>

<p>```php
function hello($name, LoopInterface $loop)
{
    $loop->addTimer(1.0, function () use ($name) {
        echo "hello $name\n";
    });
}</p>

<p>hello('Tester', $loop);
 $loop->run();
 ```</p>

<h3 id="stream"><a href="https://github.com/reactphp/stream">stream</a></h3>

<h4 id="readablestreaminterface">ReadableStreamInterface</h4>

<p>```php
$stream->on('data', function ($data) {
    echo $data;
});</p>

<p>$loop->run();
 ```</p>

<p>Forr example, the end event will be emitted once the source stream has successfully reached the end of the stream (EOF).</p>

<p>```php
$stream->on('end', function () {
    echo 'END';
});</p>

<p>$loop->run();
 ```</p>

<p>Among available events: pipe, pause, resume, close...</p>

<h4 id="writablestreaminterface">WritableStreamInterface</h4>

<p>Same idea <a href="https://github.com/reactphp/stream#writablestreaminterface">write-oriented</a>.</p>

<p>As far as I write this, this is only what I can practically test and use.</p>

<p>More to be discussed here in future : socket, promise...</p>
]]></content>
        </entry>
    </feed>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[devGiants]]></title>
    <link href="/blog/tags/REST.xml" rel="self"/>
    <link href="/"/>
    <updated>2019-10-13T09:33:11+02:00</updated>
    <id>/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Domofony presentation]]></title>
            <link href="/blog/2019/10/12/domofony-presentation/"/>
            <updated>2019-10-12T14:51:00+02:00</updated>
            <id>/blog/2019/10/12/domofony-presentation/</id>
            <content type="html"><![CDATA[<h2 id="home-automation">Home automation</h2>

<p>On my previous attempts on DIY home automation, I used the excellent <a href="https://www.openhab.org/">openHAB</a>.
At first glance, it seemed to have everything I looked for in an home automation context :</p>

<ul>
<li>Completely open-source</li>
<li><strong>Technology and vendor agnostic</strong> : one of the most important thing, I didn't want to rely on proprietary technology to build this system. Everything has to be transparent from ground to roof, and modifiable to ensure long-term usage and adaptation</li>
<li><strong>Ability to program for serious work</strong> : it's utterly important to me that real programmation feature would be available. Way I do things doesn't match with a click-land configuration job. Using <a href="https://www.eclipse.org/xtend/">Xtend</a> (because openHAB written in Java), it allows to create programs to drive your installation.</li>
</ul>

<p>So why change? Some cons :</p>

<ul>
<li>I realized after usage that all the stuff embedded (item branching with technologies, configuration...) simply wasn't for me</li>
<li>Xtend implementation in this usage, though really neat, does not allow things I wanted (such as script reuse accross handlers...)</li>
<li>All the Java stuff creates pressure on underlying hardware, thus forcing to have something powerful (old Raspberry Pis was not so good)</li>
</ul>

<p>Don't misunderstand me : OpenHAB is great job used y thousand of people accross the world. I just needed something else.</p>

<h2 id="domofony">Domofony</h2>

<p><em>Domotique</em> + <em>Symfony</em> = <a href="https://github.com/devgiants/domofony"><strong>Domofony</strong></a>.</p>

<p><em>Domotique</em> is the french word for home automation. First thing to know, I created this project for myself, and share it a good practice, but at start, not all things will be usable by everyone (such as the front-end app I plan to develop tailored to my use).</p>

<p><strong>This is a solution provided by a developer for developers</strong>. Exit click-land, all configuration is done in YAML.</p>

<h3 id="technical-components">Technical components</h3>

<p><img src="https://devgiants.fr/images/posts/domofony/technical_components_with_items.png" alt="Technical components" /></p>

<p>All part showed on above layout will be described and detailed in future posts. That being said, below is a quick description for bigger parts.</p>

<h4 id="front-end-application">Front-end application</h4>

<p>This is the application allowing user to interact with the system. It will consume REST API exposed by the server application.</p>

<h4 id="mosquitto-broker">Mosquitto broker</h4>

<p>The system relies so far on <a href="https://en.wikipedia.org/wiki/MQTT">MQTT protocol</a> 
(<a href="https://www.linkedin.com/pulse/mqtt-un-protocole-bas%C3%A9-sur-tcp-et-orient%C3%A9-iot-nicolas-bonniot/">here</a> a protocol tour in french) for exchanges between <strong>central system</strong> and <strong>items</strong>.
This protocol is ideal regarding it's asynchronous sequence and its lightweight. 
Security is not left aside, although TLS certificate usage means items must be more powerful than simple microcontrollers.</p>

<p><em>Note : an item is the end-device, such as sensor or actuator (or both). In my home automation system, this is mostly <a href="https://en.wikipedia.org/wiki/Single-board_computer">SBC</a> or ESP series microcontrollers</em></p>

<p>Future posts will handle in details <strong>items</strong>, <strong>Symfony application</strong>, <strong>Mosquitto broker &amp; client configuration</strong> and <strong>front-end application</strong>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[API versionning strategies]]></title>
            <link href="/blog/2018/12/11/api-versionning/"/>
            <updated>2018-12-11T17:04:00+01:00</updated>
            <id>/blog/2018/12/11/api-versionning/</id>
            <content type="html"><![CDATA[<h2 id="context">Context</h2>

<p>API are like any other programmed systems : they evolve during time, either with bugfixes or feature addition. There is a roadmap that can eventually bring to a <strong>backward compatibility break</strong> to ensure proper evolution regarding new features.</p>

<h2 id="versionning">Versionning</h2>

<p>Versionning is important, mainly to provide your API clients ways to ensure they use the proper version regarding their needs.</p>

<p>Few ways : 
 - Domain name : <code>https://v4.your-api.com</code>
 - URI prefix : <code>https://your-api.com/api/v4</code>
 - Query string : <code>https://your-api.com/api/?v=4.0.0</code>
 - Custom HTTP header : <code>X-API-Version: 4.0.0</code>
 - <code>Accept</code> HTTP header :  <code>Accept: application/vendor.app.your-app+json; version=4.0.0</code></p>

<p>Keep as the rule of thumb than changing URLs are <strong>generally bad idea</strong>. HTTP headers are the way to go. Below is a configuration possibility for the <code>Accept</code> header.</p>

<h2 id="fosrestbundle-configuration-for-%60accept%60-header">FOSRestBundle configuration for <code>Accept</code> header</h2>

<p>2 keys to add to FOSRestBundle configuration : <code>versionning</code> and <code>view:meme_types</code></p>

<h3 id="versionning">Versionning</h3>

<p>You need to tell FOSRestBundle you are using versionning in your app :</p>

<pre><code class="yaml">fos_rest:
  ...
  versioning:
    enabled: true
    resolvers:
      media_type: # Accept header
        enabled: true
        regex: '/(v|version)=(?P&lt;version&gt;[0-9\.]+)/'
</code></pre>

<p>Of course, you an freely adapt the regex to your needs.</p>

<h3 id="add-mime-type">Add MIME type</h3>

<p>As you can see above, the MIME type you send is now custom (<code>application/vendor.app.your-app+json; version=4.0.0</code>). You need to tell FOSRestBundle to accept it :</p>

<pre><code class="yaml">fos_rest:
  ...
  view:
    ...    
    mime_types:
      json: ['application/json', 'application/json;version=1.0', 'application/json;version=2.0']
</code></pre>

<p>For the sake of brevity, I just put the matching configurations key with <code>Accept</code> header.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[FOS REST Bundle : enforce strict behavior with query params requirements]]></title>
            <link href="/blog/2018/11/16/fos-rest-query-param-strict/"/>
            <updated>2018-11-16T17:15:00+01:00</updated>
            <id>/blog/2018/11/16/fos-rest-query-param-strict/</id>
            <content type="html"><![CDATA[<h2 id="context">Context</h2>

<p>Playing with <a href="https://github.com/FriendsOfSymfony/FOSRestBundle">FOS REST Bundle</a> on my journey to learn how to create rock-solid APIs, I started to create following action :</p>

<pre><code class="php">/**
     * @param PostHandler $postHandler
     * @param ParamFetcherInterface $paramFetcher
     * @Rest\Get("/posts/list")
     * @Rest\QueryParam(
     *     name="keyword",
     *     requirements="[a-zA-Z0-9]*",     
     *     nullable=true,
     *     description="The keyword to search for."
     * )
     * @Rest\QueryParam(
     *     name="order",
     *     requirements="asc|desc",
     *     default="asc",     
     *     description="Sort order (asc or desc)"
     * )
     * @Rest\QueryParam(
     *     name="limit",
     *     requirements="\d+",
     *     default="3",     
     *     description="Max number of posts per page."
     * )
     * @Rest\QueryParam(
     *     name="page",
     *     requirements="\d+",
     *     default="1",     
     *     description="The page wanted"
     * )
     * @Rest\View(
     *     statusCode = 200,
     *     serializerGroups = {"list"}
     * )
     *
     * @return Paginator
     */
    public function list(PostHandler $postHandler, ParamFetcherInterface $paramFetcher)
    {


        $postsList = $postHandler-&gt;search(
            intval($paramFetcher-&gt;get('limit')),
            intval($paramFetcher-&gt;get('page')),
            $paramFetcher-&gt;get('order'),
            $paramFetcher-&gt;get('keyword')
        );

        return $postsList;
    }
</code></pre>

<p>This simply expose a GET endpoint, with URL <code>/posts/list</code>, in order to return a... posts list. Several <code>QueryParam</code> can be passed in order to filter the obtained list. So, according to requirements given, following calls are acceptable (and processed) :
- <code>/posts/list?page=2</code> to get page 2, with default <code>limit</code>
- <code>/posts/list?order=desc</code> to order posts by ID descendant
- <code>/posts/list?keyword=test</code> to retrieves only posts with 'test' keyword.</p>

<h2 id="what-if...-we-don%27t-follow-requirements-%3F">What if... we don't follow requirements ?</h2>

<p>For each <code>QueryParam</code>, requirements are given in <a href="https://symfony.com/doc/current/routing/conditions.html">an regexp way</a>. Actually, requirements annotations are compiled to PHP. So, if I try :</p>

<ul>
<li><code>/posts/list?page=a</code></li>
<li><code>/posts/list?order=other</code></li>
<li><code>/posts/list?keyword=test%20test2</code></li>
</ul>

<p>What will happen? Nothing. By default, FOS REST Bundle will take <strong>the offending <code>QueryParam</code> default value instead</strong> of your offending value.</p>

<h2 id="what-if-we-want-to-raise-an-error%3F">What if we want to raise an error?</h2>

<p>Depending to which <code>QueryParam</code> you deal with, you may want to raise an error or not. For the above example, client developers will love you if you provide explicit errors and comprehensive messages for those <code>QueryParam</code>. The solution for that is simple : just add the <code>QueryParam</code> attribute <code>strict</code> to true in order to force FOS REST Bundle to raise an Exception.
With proper configuration (such as <code>ExceptionController</code>), you achieve to throw out-of-the-box exceptions like this :</p>

<pre><code>GET http://localhost:8081/posts/list?page=a

HTTP/1.1 400 Bad Request
Date: Fri, 16 Nov 2018 16:34:15 GMT
Server: Apache/2.4.18 (Ubuntu)
Cache-Control: no-cache, private
X-Debug-Token: 34ff9b
X-Debug-Token-Link: http://localhost:8081/_profiler/34ff9b
X-Previous-Debug-Token: fd05dc
Connection: close
Transfer-Encoding: chunked
Content-Type: application/json

{
  "error": "Parameter \"page\" of value \"a\" violated a constraint \"Parameter 'page' value, does not match requirements '\\d+'\""
}

Response code: 400 (Bad Request); Time: 4106ms; Content length: 137 bytes
</code></pre>
]]></content>
        </entry>
    </feed>